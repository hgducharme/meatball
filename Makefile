SHELL = /bin/sh
appname := meatball

# -------------------------------------- #
# Customizable paths and executables
# -------------------------------------- #
PROJECT_DIR := .
SOURCE_DIR := $(PROJECT_DIR)/src
TEST_DIR := $(PROJECT_DIR)/test
UNIT_TEST_DIR := $(TEST_DIR)/unit
INTEGRATION_TEST_DIR := $(TEST_DIR)/integration
BUILD_DIR := $(PROJECT_DIR)/build
BIN_DIR := $(PROJECT_DIR)/bin
COVERAGE_DIR := $(PROJECT_DIR)/test_coverage
TEST_UTILS_DIR := $(TEST_DIR)/utils

EXECUTABLE = $(BIN_DIR)/$(appname)
TEST_EXECUTABLE = $(BIN_DIR)/tests
UNIT_TEST_EXECUTABLE = $(BIN_DIR)/unit_tests
INTEGRATION_TEST_EXECUTABLE = $(BIN_DIR)/integration_tests

DOCKER_DIR = $(PROJECT_DIR)/docker
DOCKERFILE_BUILD_ENV_PATH = $(DOCKER_DIR)/Dockerfile.buildEnv
DOCKER_BUILD_ENV_IMAGE_NAME = build-env
DOCKER_BUILD_ENV_CONTAINER_NAME = $(appname)-$(DOCKER_BUILD_ENV_IMAGE_NAME)
DOCKER_SHELL_ENV = /bin/sh

# -------------------------------------- #
# Compiling configuration
# -------------------------------------- #
# Compiler
CXX := clang++

# Compiler flags
DEBUG = -g
COVERAGE := -O0 -fPIC --coverage # (--coverage is a synonym for: -fprofile-arcs -ftest-coverage)
CPP = 17
CXXFLAGS := -Wall -Wextra -fdiagnostics-color=always -std=c++${CPP} $(DEBUG) $(COVERAGE)

# C PreProcessor flags, generally used for path management, dependency file generation, and dumping preprocessor state
# Include source subdirectories and generate dependency files during compilation
source_subdirectories := $(shell find $(SOURCE_DIR) -type d)
include_source_subdirectories := $(addprefix --include-directory=, $(source_subdirectories))
CPPFLAGS := $(include_source_subdirectories) --write-user-dependencies -MP

COMPILE.cpp := $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) --compile

# -------------------------------------- #
# Linking configuration
# -------------------------------------- #
# Tell the linker to look inside these directories to find the libraries passed into LDLIBS
# flags should look like: "-L/path/to/lib/dir"
# LDFLAGS :=

# Link to libraries
# LDLIBS := 

LINK.cpp := $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)

# -------------------------------------- #
# Libraries
# -------------------------------------- #
# googletest flags for the linker
GOOGLETEST := --library-directory /usr/local/lib -lgtest -lgtest_main

# -------------------------------------- #
# Docker configuration
# -------------------------------------- #
IF_CONTAINER_RUNNING=$(shell docker container inspect -f '{{.State.Running}}' ${DOCKER_BUILD_ENV_CONTAINER_NAME} 2>/dev/null)

DOCKER_RUN_OPTIONS = --rm -t --name=$(DOCKER_BUILD_ENV_CONTAINER_NAME) --mount type=bind,source=${PROJECT_DIR},target=/usr/src/app ${appname}/$(DOCKER_BUILD_ENV_IMAGE_NAME):0.1
DOCKER_RUN = docker run $(DOCKER_RUN_OPTIONS)
DOCKER_INTERACTIVE_RUN = docker run -it $(DOCKER_RUN_OPTIONS)

# -------------------------------------- #
# Files
# -------------------------------------- #
# Source code files
sourcefiles := $(shell find $(SOURCE_DIR) -name "*.cpp")
objectfiles := $(sourcefiles:%.cpp=$(BUILD_DIR)/%.o)
sourcefiles_without_main = $(filter-out $(SOURCE_DIR)/main.cpp, $(sourcefiles))
objectfiles_without_main = $(filter-out $(BUILD_DIR)/./src/main.o, $(objectfiles))

# Test code files
test_utility_sourcefiles := $(shell find $(TEST_UTILS_DIR) -name "*.cpp")
test_utility_objectfiles := $(test_utility_sourcefiles:%.cpp=$(BUILD_DIR)/%.o)

unit_test_sourcefiles := $(shell find $(UNIT_TEST_DIR) -name "test_*.cpp")
unit_test_objectfiles := $(unit_test_sourcefiles:%.cpp=$(BUILD_DIR)/%.o)

integration_test_sourcefiles := $(shell find $(INTEGRATION_TEST_DIR) -name "test_*.cpp")
integration_test_objectfiles := $(integration_test_sourcefiles:%.cpp=$(BUILD_DIR)/%.o)

test_sourcefiles := $(unit_test_sourcefiles) $(integration_test_sourcefiles) $(test_utility_sourcefiles)
test_objectfiles := $(unit_test_objectfiles) $(integration_test_objectfiles) $(test_utility_objectfiles)

# All files
all_sourcefiles := $(sourcefiles) $(test_sourcefiles)
all_objectfiles := $(objectfiles) $(test_objectfiles)

# Files generated by gcov for test coverage
gcov_files = $(shell find $(BUILD_DIR) -name "*.gcno")

# -------------------------------------- #
# Targets
# -------------------------------------- #

##
## Executables
##

meatball: ## Build the main executable
$(appname): $(objectfiles) | $(BIN_DIR)
	@echo
	@echo "Generating executable: $@"
	@echo "Linking file(s): $^"
	$(LINK.cpp) $^ $(LDLIBS) --output $(EXECUTABLE)

# Build the test executable by linking source objects (without main.o) and test objects
tests: ## Build unit and integration tests into one executable
tests: $(objectfiles_without_main) $(test_objectfiles) | $(BIN_DIR)
	@echo
	@echo "Generating executable: $@"
	@echo "Linking file(s): $^"
	$(LINK.cpp) $^ $(GOOGLETEST) --output $(TEST_EXECUTABLE)

# Build the unit tests executable by linking source objects (without main.o) and unit test objects
unit_tests: ## Build the unit tests executable
unit_tests: $(objectfiles_without_main) $(unit_test_objectfiles) $(test_utility_objectfiles) | $(BIN_DIR)
	@echo
	@echo "Generating executable: $@"
	@echo "Linking file(s): $^"
	$(LINK.cpp) $^ $(GOOGLETEST) --output $(UNIT_TEST_EXECUTABLE)

# Build the integration tests executable by linking source objects (without main.o) and integration test objects
integration_tests: ## Build the integration tests executable
integration_tests: $(objectfiles_without_main) $(integration_test_objectfiles) $(test_utility_objectfiles) | $(BIN_DIR)
	@echo
	@echo "Generating executable: $@"
	@echo "Linking file(s): $^"
	$(LINK.cpp) $^ $(GOOGLETEST) --output $(INTEGRATION_TEST_EXECUTABLE)

##
## Builds
##

build: ## Build the source code
build: $(objectfiles)
	@echo

coverage-report: ## Run the tests and build a coverage report
coverage-report: tests | $(COVERAGE_DIR)
	@echo
	@echo "Generating test coverage data..."
	./$(TEST_EXECUTABLE)
	gcov --color $(sourcefiles_without_main) -o=$(BUILD_DIR)/src
	mv *.gcov $(COVERAGE_DIR)/gcov
	gcovr --exclude-unreachable-branches --exclude-throw-branches --decisions --html-details $(COVERAGE_DIR)/html/coverage.html $(BUILD_DIR)/src

# Compile .cpp into .o
$(objectfiles) $(test_objectfiles): $(BUILD_DIR)/%.o: %.cpp
	@echo
	@echo "Compiling: '$<'"
	mkdir -p $(dir $@)
	$(COMPILE.cpp) $< --output $@

# -------------------------------------- #
# Docker targets
# -------------------------------------- #

##
## Docker
##
## You can specify build flags to pass through to the docker container using BUILD_FLAGS=""
## (e.g., make docker-build BUILD_FLAGS="CXX=g++ CPP=17")
##

docker-build-env: ## Generate a docker image containing the build environment
	@echo "Generating a docker image with the build environment dependencies..."
	docker build -t $(appname)/$(DOCKER_BUILD_ENV_IMAGE_NAME):0.1 -f $(DOCKERFILE_BUILD_ENV_PATH) .
	@echo
	@echo "Pruning unused docker images..."
	docker image prune -f

docker-build: ## Build the source code in a docker container
	@echo "Running build in docker container..."
	$(DOCKER_RUN) make build $(BUILD_FLAGS)

docker-tests: ## Build and run the unit and integration tests in a docker container
	@echo "Running unit and integration tests in docker container..."
	$(DOCKER_RUN) sh -c 'make tests $(BUILD_FLAGS) && $(TEST_EXECUTABLE)'

docker-unit-tests: ## Build and run the unit tests in a docker container
	@echo "Running unit tests in docker container..."
	$(DOCKER_RUN) sh -c 'make unit_tests $(BUILD_FLAGS) && $(UNIT_TEST_EXECUTABLE)'

docker-integration-tests: ## Build and run the integration tests in a docker container
	@echo "Running integration tests in docker container..."
	$(DOCKER_RUN) sh -c 'make integration_tests $(BUILD_FLAGS) && $(INTEGRATION_TEST_EXECUTABLE)'

docker-login: ## Log into the build environment container. Note: if the container is already running, login into existing one
	@if [ "${IF_CONTAINER_RUNNING}" == "true" ]; then \
		echo "\nFound running container, attaching to it...\n"; \
		docker exec -it $(DOCKER_BUILD_ENV_CONTAINER_NAME) sh; \
	else \
		echo "\nStarting an interactive docker container session, you can exit with ctrl+D... \n"; \
		$(DOCKER_INTERACTIVE_RUN); \
	fi

docker-stop: ## Stop the docker container if it's running
	@if [ "${IF_CONTAINER_RUNNING}" == "true" ]; then \
		echo "\nStopping running container '$(DOCKER_BUILD_ENV_CONTAINER_NAME)'\n"; \
		docker stop $(DOCKER_BUILD_ENV_CONTAINER_NAME); \
	else \
		echo "\nNo container to stop, exiting."; \
	fi

# -------------------------------------- #
# File Targets
# -------------------------------------- #

.PHONY: $(BIN_DIR)
$(BIN_DIR):
	@echo
	mkdir -p $@

.PHONY: $(COVERAGE_DIR)
$(COVERAGE_DIR):
	@echo
	mkdir -p $@/gcov
	mkdir -p $@/html

# -------------------------------------- #
# Clean
# -------------------------------------- #

##
## Clean
##

.PHONY: clean
clean: ## Remove all build artifacts
	$(RM) -r $(BIN_DIR) $(BUILD_DIR) $(COVERAGE_DIR)

.PHONY: clean-tests
clean-tests: ## Remove test build artifacts
	$(RM) -r $(TEST_EXECUTABLE) $(BUILD_DIR)/test

.PHONY: clean-coverage
clean-coverage: ## Remove coverage build artifacts
	$(RM) -r $(COVERAGE_DIR)

# -------------------------------------- #
# Misc commands
# -------------------------------------- #

##
## Misc commands
##

.PHONY: help
help: ## (Default) Show this help screen
	@printf "\nUsage: make <target>\n"
	@gawk -vG=$$(tput setaf 2) -vR=$$(tput sgr0) ' \
	match($$0, "^(([^#:]*[^ :]) *:)?([^#]*)##([^#].+|)$$",a) { \
		if (a[2] != "") { printf "    make %s%-18s%s %s\n", G, a[2], R, a[4]; next }\
		if (a[3] == "") { print a[4]; next }\
		printf "\n%-36s %s\n","",a[4]\
	}' $(MAKEFILE_LIST)
	@echo "" # blank line at the end

.DEFAULT_GOAL := help

# -------------------------------------- #
# Dependencies
# -------------------------------------- #
dependencies := $(all_objectfiles:.o=.d)

-include $(dependencies)